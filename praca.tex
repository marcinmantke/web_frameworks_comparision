\documentclass[mgr,oneside]{mgr}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\frenchspacing
\linespread{1.5}
\usepackage{indentfirst}
\usepackage{caption}
\usepackage{subcaption}


\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{
	backgroundcolor=\color{white},   % choose the background color
	basicstyle=\footnotesize,        % size of fonts used for the code
	breaklines=true,                 % automatic line breaking only at whitespace
	frame=single,
	commentstyle=\color{mygreen},    % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	keywordstyle=\color{blue},       % keyword style
	stringstyle=\color{mymauve},     % string literal style
}

\author{inż. Marcin Mantke}
\title{Analiza porównawcza popularnych frameworków webowych.}
\engtitle{Comparative analysis of most popular web frameworks.}
\supervisor{dr inż. Roman Ptak}
\field{Informatyka (INF)}
\specialisation{Inżynieria systemów informatycznych (INS)}
\date{2017}

\begin{document}
\maketitle
\tableofcontents
% dodać rozdział z~wstępem teoretycznym, teoria do metod porównywania (5 rozdzial)
\chapter{Wstęp}
\section{Ogólny opis pracy}
W momencie pisania pracy istnieje niezliczona ilość frameworków webowych. Prawie codziennie, dla samego języka JavaScript, powstaje jeden nowy (micro) framework. Przyczyn takiego stanu rzeczy jest kilka. Po pierwsze, problemy, z~jakimi spotykają się programiści są bardzo zróżnicowane oraz skomplikowane. Wynika to z~nacisku biznesu, czyli klientów, na to, aby nowo powstały proukt był innowacyjny. Programista oczywiście posiada narzędzia, które powinny być wystarczające do rozwiązania powierzonego mu problemu, jednakże niekiedy korzystanie z~narzuconych przez framework rozwiązań wręcz utrudnia wykonanie powierzonej pracy. Z~tego powodu powstają nowe frameworki, które udostępniają zestaw narzędzi ukierunkowany pod rozwiązanie nowego, konkretnego problemu. Druga przyczyna jest w~pewien sposób powiązana z~pierwszą. Jest to stworzenie frameworku nie w~odpowiedzi na potrzebę, ale wygenerowanie potrzeby poprzez stworzenie frameworku, który ułatwia rozwiązanie przykładowego problemu. Kolejnym powodem jest próba odchudzenia istniejących frameworków. Przykładem może być Ruby~on~Rails, który jest frameworkiem kompletnym, ale niekiedy posiadającym zbyt dużo wbudowanych funkcji, z~których trudno jest zrezygnować, a~które w~danym projekcie nie zostaną wykorzystane. Zwiększa to rozmiar oraz złożoność projektu, co oczywiście jest niekorzystne.

Ilość dostępnych frameworków pokazuje jak ważnym elementem stały się one dla programistów. Niestety, tak dynamiczny rozwój rozwiązań tego typu powoduje spory problem jeśli chodzi o~wybór technologii. Ninejsza praca ma na celu zaprezentowanie wybranych frameworków webowych oraz dokonanie porównania ich funkcjonalności oraz wydajności. Analiza porównawcza ma na celu wyszczególnienie cech frameworków, na które programista powinien zwrócić szczególną uwagę przy doborze frameworku.

Jako że framework dodaje do aplikacji pewną warstwę abstrakcji, czyli kod, naturalny jest narzut wydajnościowy na aplikację. z~tego powodu, poza różnymi cechami odnośnie budowy i~dostarczanych funkcjonalności, frameworki różnią się również wydajnością.

\section{Cel pracy}
Celem niniejszej pracy jest dokonanie analizy porównawczej wybranych frameworków webowych. Analiza ta ma posłużyć do wyciągnięcia wniosków na temat cech poszczególnych rozwiązań, a także ich wydajności. Dokumentacja zawiera opis implementacji testowej aplikacji przy pomocy każdego z frameworków oraz wnioski z analizy testów.

Aby poprawnie zrealizować cel pracy, stworzono aplikację testową. W celu urzeczywistnienia problemu, który rozwiązuje owa aplikacja, postanowiono stworzyć rozwiązanie umożliwiające zarządzanie inteligentnym domem. Aplikacja ta pełni rolę jednostki zarządzającej podzespołami inteligentnego domu oraz zbierającej dane z czujników. Spełnia ona następujące wymagania funkcjonalne:
\begin{itemize}
  \item rejestracja i logowanie użytkowników,
  \item przetwarzanie danych w tle,
  \item możliwość dodawania, edycji oraz usuwania sensorów,
  \item możliwość dodawania oraz usuwania danych z sensorów,
  \item przypisywanie danych do sensorów.
\end{itemize}

Aplikacja spełnia również następujące wymagania niefunkcjonalne:
\begin{itemize}
  \item połączenie z bazą danych PostgreSQL,
  \item zapewnienie skalowalności aplikacji,
  \item posiadanie testów jednostkowych.
\end{itemize}

\chapter{Przedstawienie omawianych technologii}
\section{Historia i~rozwój technologii webowych}
Od lat 90 XX wieku świat obserwuje bardzo dynamiczny rozwój technologii związanych z~Internetem. Począwszy od roku 1991, kiedy to naukowcy z~instytu badawczego \textbf{CERN} (ang. \textit{European Organization for Nuclear Research}) opracowali standard WWW, przed programiastami zaczęła się otwierać nowa gałąź tworzenia aplikacji, którą są aplikacje internetowe. Początkowo aplikacje te były jedynie statycznymi stronami WWW, na których znajdował się jedynie tekst. Wprowadzenie kaskadowych arkuszy styli (\emph{CSS}) w~roku 1996 sprawiło, że strony internetowe przybrały graficzną formę. Rok 1997 przyniósł obsługę języka \emph{JavaScript} w~przeglądarkach internetowych. Oznaczało to, że strony internetowe, poza statycznymi elementami, zyskały elementy dynamiczne, np. reagujące na akcje użytkownika.

Wraz ze wzrostem dostępu ludzi do Internetu rozwijały się technologie odpowiedzialne za strony internetowe. Za punkt początkowy istnienia nie stron, a~aplikacji internetowych, można przyjać rok 1997 i~powstanie języka \emph{PHP}. Był to pierwszy interpretowany skryptowy język programowania, który służył do budowania aplikacji internetowych działających w~czasie rzeczywistym. Wraz z~rozwojem języka PHP oraz innych, podobnych mu języków, np. \emph{Python} i~\emph{Ruby}, zmienił się sposób budowania aplikacji. Programiści zaczęli rezygnować ze standardowych klientów w~postaci aplikacji desktopowych i~przechodzili na tzw. cienkich klientów (ang. \textit{thin client}). Trend ten przyspiesza rozwój oraz różnorodność aplikacji serwerowych posiadających interfejs graficzny w~formie strony internetowej, które nazywane są aplikacjami internetowymi \cite{historia}.

\section{Wykorzysywane pojęcia i terminy}
\subsection{Aplikacja internetowa}
Aplikacja internetowa (webowa) jest aplikacją znajdującą się nie na komputerze użytkownika, lecz na ogólnodostępnym serwerze. Komunikacja pomiędzy, niekiedy rozproszonymi, elementami aplikacji odbywa się poprzez sieć komputerową. Aplikacja webowa swój interfejs graficzny poprzez przeglądarkę internetową bądź np. aplikację mobilną.

\subsection{Framework webowy} % moduły i~biblioteki, np do połączenia z~bazą danych
Aby ułatwić korzystanie z~coraz liczniejszych technologii wykorzystywanych w~tworzeniu aplikacji internetowych, powstały narzędzia nazywane frameworkami webowymi. Framework jest uniwersalnym środowiskiem programistycznym, które dostarcza niezbędne narzędzia wymagane do stworzenia aplikacji internetowej w~wybranym języku programowania \cite{framework}. Każdy z~frameworków dostarcza pewną abstrakcję, która znajduje się wokół kodu napisanego przez programistę. Przykładem takiej abstrakcji jest system mapowania ścieżki podstrony (np. \textit{/users/3}) na konkretną akcję w~aplikacji (zwykle akcja \emph{SHOW} dla kontrolera \emph{Users}), czyli \emph{routing}. Twórcy frameworków zauważyli, że w~każdej aplikacji webowej są stosowane te same typy rozwiązań, więc w~wielu przypadkach wprowadzili dane rozwiązania jako integralne części frameworków. W~efekcie programiści mogą korzystać z~gotowych, dogłębnie przetestowanych rozwiązań, które znajdują się w~90\% aplikacji webowych.

\subsection{Wirtualizacja, kontener} % https://dsg.cs.put.poznan.pl/wiki/_media/workshop/docker-skisr.pdf
W celu zapewnienia izolacji środowiska działania aplikacji, stosuję się technikę nazywaną wirtualizacją. Polega ona na stworzeniu wirtualnej maszyny, bądź też kontenera, gdzie uruchamiana jest aplikacja. Rozwiązania te, pomimo osiągania podobnego efektu, różnią się pomiędzy sobą pod wieloma względami.

\begin{figure}[h]
  \centering
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=.6\linewidth]{images/docker_container}
    \label{fig:docker_container}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=.6\linewidth]{images/docker_vm}
    \label{fig:docker_vm}
  \end{subfigure}
  \caption{Porównanie kontenerów i wirtualnej maszyny.}
\end{figure}

Korzystając z informacji zawartych w dokumentacji Docker'a \cite{docker_what_container}, można wykazać następujące cechy obu rozwiązań:

\begin{itemize}
  \item maszyny wirtualne:
  \begin{itemize}
    \item abstrakcja w warstwie sprzętowej, która zmienia jeden serwer w wiele serwerów,
    \item hipernadzorca (ang. \textit{hypervisor}) pozwala na pracę wielu wirtualnych maszyn na jednej maszynie fizycznej,
    \item każda maszyna wirtualna posiada pełną kopię systemu operacyjnego, aplikacji, niezbędnych bibliotek i ich zależności, przez co zajmuje dużo miejsca na dysku twardym,
    \item maszyny wirtualne zwykle długo się uruchamiają.
  \end{itemize}

  \item kontenery:
  \begin{itemize}
    \item abstrakcja w warstwie aplikacji, która łączy kod z jego zależnościami,
    \item na jednej maszynie może być uruchomionych wiele kontenerów, które wspóldzielą kernel,
    \item każdy z kontenerów jest osobnym procesem w przestrzeni użytkownika,
    \item kontenery zajmują mniej miejsca na dysku i uruchamiają się dużo szybciej, niż maszyny wirtualne.
  \end{itemize}
\end{itemize}

Powyższe zestawienie należy uzupełnić o informacje znajdujące się w prezentacji Łukasza Piątkowskiego \cite{docker_prez}:
\begin{itemize}
  \item maszyny wirtualne:
  \begin{itemize}
    \item wirtualizacja sprzętu - degradacja wydajności,
    \item własny kernel,
    \item pełna maszyna,
  \end{itemize}

  \item kontenery:
  \begin{itemize}
    \item \textit{chroot} z większymi możliwościami,
    \item wspólny kernel,
    \item własne zasoby pamięci, dysku, I/O.
  \end{itemize}
\end{itemize}

Analizując cechy obu rozwiązań można stwierdzić, że kontenery mają sporą przewagę w ważnych kwestiach (wydajność, szybkość uruchamiania, wymagane zasoby) nad maszynami wirtualnymi, dlatego też stają się coraz bardziej popularne.

Ze strony programisty, otrzymuje on nową instancję wybranego systemu, gdzie zainstalowane są jedynie zależności wymagane przez daną aplikację. Prowadzi to do odizolowania środowiska aplikacji, przez co znacząco minimalizowane jest ryzyko wystąpienia konfliktów pomiędzy aplikacjami, aplikację można w bardzo prosty sposób przenieść na inną maszynę i uruchomić ją jedną komendą.

\subsection{CRUD}
CRUD, to cztery podstawowe funkcje w aplikacjach korzystających z pamięci trwałej, które umożliwiają zarządzanie nią \cite{wiki_crud}. Akronim ten powstał od pierwszych liter słów \textbf{C}reate, \textbf{R}ead, \textbf{U}pdate i \textbf{D}elete. Określa on udostępnienie użytkownikowi bądź aplikacji zestaw operacji (stworzenie, odczytanie, aktualizacja oraz usunięcie) na danym obiekcie.

\chapter{Przegląd wybranych rozwiązań}
\section{Ruby on Rails}
Ruby on Rails jest open source'owym frameworkiem webowym. Został stworzony w~głównej mierze przez duńskiego programistę Davida Heinemeiera Hanssona. Pierwsza wersja RoR ukazała się w~lipcu 2004 roku. Fakt ten pokazuje, że jest to już dojrzały framework, z~ugruntowaną pozycją na rynku. Potwierdzeniem tej pozycji jest liczne wsparcie społeczności. Rails'y zostały stworzone przez ponad 4,5 tysiąca osób, istnieje ok. 132 tysiące ogólnodostępnych paczek, które rozszerzają funkcjonalność tego frameworku. Ruby on Rails domyślnie korzysta z~architektury MVC, czyli \emph{Model - View - Controller}.

\subsection{Doktryna Ruby on Rails}
Tworzeniu i~rozwojowi Ruby on Rails towarzyszy kilka podstawowych zasad. Jedne istnieją od początku, inne ewoluowały na przestrzeni lat. Spisane są one w~\emph{The Rails Doctrine} \cite{rails_doctrine}. Na potrzeby pracy zostaną omówione najważniejsze z nich.

\subsubsection{Optimize for programmer happiness}
Pierwsza reguła odnosi się mocno do języka, z~którego wywodzą się Rails'y. Sam fakt umieszczenia nazwy języka Ruby w~nazwie frameworku pokazuje jak ważny jest on dla całego projektu. Motywacją stworzenia języka Ruby była chęć dostarczenia programistom radości z~pisania kodu. w~momencie powstawania Ruby'ego, większość popularnych wtedy języków programowania narzucało sposób pisania bądź stosowało liczne ograniczenia w~sposobie pisania kodu. Ruby stał w~opozycji do tych zasad, dając programistom pełną dowolność w~sposobie tworzenia kodu.

Jako przykład owego ,,uwolnienia'' programisty podawana jest \emph{Zasada Najmniejszego Zaskoczenia} (ang. The Principle of Least Surprise).
\begin{lstlisting}[caption={Wyjście z~interpretera Ruby'ego.},language=Ruby]
$ irb
irb(main):001:0> exit
$ irb
irb(main):001:0> quit
\end{lstlisting}

\begin{lstlisting}[caption={Wyjście z~interpretera Python'a.},language=Python]
$ python
>>> exit
Use exit() or Ctrl-D (i.e. EOF) to exit
\end{lstlisting}
Ruby zaakceptuje oba polecenia opuszczenia interpretera. Python natomiast, pomimo odczytania intencji programisty (wyświetlenie instrukcji), opuści interpreter jedynie po wpisaniu komendy \emph{exit()} lub po użyciu kombinacji klawiszy \emph{Ctrl-D}, co oczywiście nie jest zgodne z~oczekiwaniami programisty.

Wzorując się na zasadach, na których powstawał Ruby, Rails'y również miały umilać życie programistom. Jako przykład jest podawana klasa \emph{Inflector}. Zapisane są w~niej reguły oraz wyjątki od reguł w~języku angielskim, które umożliwiają mapowanie klasy \emph{Comment} na tabelę \emph{Comments}, \emph{Person} na \emph{People} itp. Kolejnym przykładem może być dodatek do Ruby'owej klasy \emph{Array}, który poza dostępnym w~Rubym pierwszym elementem tablicy, umożliwia dostęp do kolejnych czterech elementów tablicy, poprzez wyrażenia \emph{Array\#second,~Array\#third} itd.

Oczywiście nie są to kluczowe cechy frameworku, ale stanowczo zaznaczają ważkość celu, którym jest przede wszystkim sprawianie radości z~tworzenia oprogramowania.

\subsubsection{Convention over Configuration}
Twórcy Ruby on Rails starają się kłaść mocny nacisk na prostotę używania ich narzędzia. Zamiast zrzucać na programistów ciągłe podejmowanie decyzji w~kwestiach mało istotnych, jak na przykład format klucza obcego w~bazie danych, Rails'y narzucają konwencję nazewnictwa. Oczywiście jest możliwość konfiguracji narzuconych przez framework konwencji, lecz jest to raczej rzadko spotykane, a~wręcz niewskazane. Zasada ta, poza zdjęciem odpowiedzialności za część decyzji z~barków programisty, przynosi również inne korzyści.

Dzięki ,,domyślnej'' konwencji, możliwe jest stworzenie głębszej abstrakcji, na której operuje framework. Przykładem może być zastosowanie wcześniej wymienionej klasy \emph{Inflector}. Jeśli możliwe jest zmapowanie klasy \emph{Person} na tabelę \emph{People}, to możliwe jest również zmapowanie relacji \emph{has\_many: people} w~taki sposób, aby wykorzystywana była klasa \textit{Person}. Jest to o~tyle wygodne rozwiązanie, że nawet pomimo posiadania wiedzy na temat tworzenia relacji w~bazie danych oraz sposobu odzwierciedlania ich w~kodzie aplikacji, programista nie musi przejmować się tworzeniem lub konfiguracją tej części aplikacji.

Kolejną zaletą jest znaczące obniżenie progu wejścia dla początkujących programistów. Takim osobom dużo łatwiej jest poznawać framework stopniowo. Począwszy od poziomu, gdzie wszystko automatycznie działa, lecz nie wiadomo dlaczego, aż do momentu gdzie nadal wszystko automatycznie działa, ale bardzo dobrze wiadomo dlaczego. Znaczna część mechanizmów stosowanych we frameworkach webowych \emph{de facto} nie wymaga niestandardowej konfiguracji, nawet jeśli programista posiada szeroką wiedzę w~danej dziedzinie. Przekładanie konfiguracji ponad konwencję wymaga od programisty sporego wysiłku, aby rozpocząć pracę z~frameworkiem, co w przypadku poznawania nowych technologii stanowczo nie jest zachęcające.

Zasada ta bywa jednak zgubna. Jest tak z~powodu błędnego przekonania, że skoro od samego początku wszystkie elementy aplikacji można wygenerować, i~od samego początku wszystko działa, to programista nie musi mieć wiedzy na temat tego, co robi. W~przypadku bardzo podstawowych zastosowań wiedza programisty rzeczywiście nie musi być szeroka, natomiast bardzo problematyczne jest w~takim przypadku wykonanie części aplikacji, która jest niestandardowa bądź niemożliwa do wygenerowania.

\subsubsection{The menu is omakase}
Rzadko kiedy framework jest monolitem, który nie składa się z~modułów. Częściej framework jest zbiorem mniejszych frameworków lub bibliotek, które współpracują ze sobą. Bardzo często wybór owych narzędzi leży w~pełni po stronie programisty. Jako analogię takiego wyboru, w \emph{The Ruby on Rails Doctrine} podawany jest problem wyboru dania z~menu w~restauracji, którą odwiedzamy po raz pierwszy. Jeśli zdamy się na wybór szefa kuchni, możemy założyć że jedzenie będzie dobre, nie wiedząc jeszcze co ,,dobre'' będzie oznaczać \cite{rails_doctrine}.

Ruby on Rails rozwiązuje ten problem poprzez dostarczenie zestawu narzędzi, z~których programista może korzystać. Zasada działania jest tutaj bardzo zbliżona do reguły \emph{Convention over Configuration}, lecz operuje na wyższym poziomie abstrakcji. Programista dostaje zestaw domyślnych narzędzi, z~którego może od samego początku korzystać, bez potrzeby podejmowania decyzji odnośnie wyboru frameworków i~bibliotek. Ma on natomiast możliwość zamiany domyślnie wybranych narzędzi na inne, jeśli widzi taką potrzebę.

Zasada ta niesie za sobą korzyści w~sferze rozwoju frameworku. Jest tak, ponieważ programiści, używając tych samych narzędzi, są w~stanie bardziej dopracować owe narzędzia. Częstym problemem jest nie fakt jak działa dany framework bądź biblioteka w~izolacji, lecz jak działa razem z~innymi modułami. Jeśli wielu programistów napotyka te same błędy w~integracji poszczególnych składowych frameworku, to dużo łatwiej jest twórcom takie błędy poprawić bądź usprawnić połączenie tych modułów.

\subsubsection{No one paradigm}
Twórcy frameworka Ruby on Rails są przekonani, że nie istnieje jedno idealne rozwiązanie. Często do jednego celu można dojść różnymi drogami. Z~tego też powodu, pomimo wyboru architektury MVC, Railsy są bardzo elastyczne jeśli chodzi o~dostosowanie się do innych modeli projektowych. Domyślnie RoR nie posiada wbudowanych \textit{Serwisów} bądź \textit{Prezenterów}, lecz framework jest zbudowany w~taki sposób, aby użycie większości wzorców projektowych było bezproblemowe.

Przystosowanie frameworku do korzystania z~różnych wzorców projektowych poniekąd wymusza na programistach znajomość większej ilości owych wzorców. Jako, że Ruby jest bardzo elastycznym językiem jeśli chodzi o~paradygmaty programowania, ponieważ możliwe jest pisanie funkcyjne, Railsy również wspierają owe podejście. Od programisty zależy, czy z~takiej możliwości skorzysta. Wprowadzenie takiej uniwersalności niestety niesie za sobą spory nakład pracy ze strony twórców.

\subsection{Pozostałe cechy}
Poza cechami wymienionymi w \textit{The Ruby on Rails Doctrine}, Ruby on Rails kładzie mocny nacisk na inne aspekty. Są to m.in. kwestie takie, jak przestrzeganie reguły \textit{DRY} (ang. \textit{Don't Repeat Yourself}) bądź też wsparcie dla dodatkowych bibliotek rozszerzających funkcjonalność frameworku.

\subsubsection{Don't Repeat Yourself}
Reguła \textit{DRY} mówi o tym, aby, jak sama nazwa wskazuje, nie powtarzać kodu. Każde powtórzenie logiki biznesowej może być rozwiązane poprzez dodanie warstwy abstrakcji. Natomiast duplikację procesów można rozwiązać poprzez ich automatyzację \cite{dry}. Poprzez stosowanie tej reguły, kod aplikacji jest wyraźnie mniejszy, ale przede wszystkim jest on bardziej odporny na błędy i łatwiejszy w utrzymaniu. Jeśli w~powtarzającym się fragmencie kodu zostanie popełniony błąd, dzięki zastosowaniu reguły DRY, zmianę trzeba wprowadzić tylko w~jednym miejscu, a~nie w~każdym wystąpieniu powtarzającej się funkcji.

Ruby on Rails wspiera używanie tej reguły poprzez wbudowane w framework elementy, takie jak \textit{Helpery}, \textit{Concerny} lub \textit{Partiale}. Umożliwiają one wspóldzielenie kodu i używanie ich w każdej z warstw aplikacji.

\subsubsection{Biblioteki}
Biblioteki tworzone przez społeczność nie są bezpośrednio elementem frameworku, ale samego języka Ruby. Ich nazwa to \textit{gem'y}. Rails'y natomiast mają domyślnie dołączony menedżer bibliotek/pakietów - \textit{bundler}.

\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{images/bundler_stats}
  \caption{Statystyki pobrań menedżera pakietów bundler.}
  \label{fig:bundler_stats}
\end{figure}

Jak widać, \textit{bundler} jest najczęściej pobieranym \textit{gem'em} spośród wszystkich, z ilością pobrań przekraczającą 162,5 miliona. Ogromny wpływ na taki wynik mają oczywiście Rails'y. Strona \url{https://rubygems.org/}, która jest źródłem większości bibliotek, w statystykach podaje, że dostępnych jest ponad 131,600 paczek. Pokazuje to jak ważną częścią dla twórców Ruby on Rails i całej społeczności jest możliwość tworzenia rozszerzeń oraz ich dostępność.

\section{Phoenix} % https://media.pragprog.com/titles/phoenix/intro.pdf   http://www.phoenixframework.org/docs/resources

\textit{Phoenix} jest open source'owym frameworkiem webowym napisanym w języku \textit{Elixir}. Inicjatorem tego projektu jest amerykanin Chris McCord. Pierwsza wersja \textit{Phoenix'a} została wydana 28 sierpnia 2015 roku, a więc jest to bardzo młody framework. Pomimo swojego młodego wieku, framework ten zyskał sporą popularność i zainteresowanie społeczności. Jest to spowodowane ideą frameworku, który nie stara się być na siłę inny od istniejących rozwiązań, a zamiast tego stara się wykorzystywać ich najlepsze elementy. Jako przykładowe frameworki, z których czerpie \textit{Phoenix}, wymieniane są \textit{Ruby on Rails} oraz \textit{Django} \cite{phoenix_docs}.

Tak, jak większość frameworków webowych, \textit{Phoenix} implementuje wzorzec \textit{Model-View-Controller}.

\subsection{Podstawowe założenia}
Idea działania \textit{Phoenix'a} opiera się na kilku podstawowych założeniach:
\begin{itemize}
  \item szybkość działania,
  \item współbieżność,
  \item wygoda użytkowania,
  \item niezawodność.
\end{itemize}

\subsubsection{Szybkość działania}
Położenie nacisku na szybkość działania aplikacji stworzonej przy pomocy frameworka jest czymś naturalnym. Zwykle jednak szybkość działania osiągana jest kosztem innych aspektów tworzenia aplikacji, jak na przykład szybkością powstawania oprogramowania. Aby osiągnąć zadowalającą szybkość działania, twórcy \textit{Phoenix'a} zdecydowali się stworzyć framework przy pomocy języka \textit{Elixir}. Wpływ tego języka na framework opisany jest szerzej w sekcji \ref{phoenix:elixir}.

Poza samym językiem programowania, na szybkość działania aplikacji wpływ mają następujące rozwiązania:
\begin{itemize}
  \item router kompilowany jest do bardzo szybkiego w działaniu \textit{pattern matching'u}, czyli dopasowaniu do wzorca. Dzięki temu optymalizacja wydajności wykonywana jest jeszcze zanim zapytanie opuści router,
  \item template'y są prekompilowane, \textit{Phoenix} nie musi kopiować łańcuchów tekstowych dla każdego wyświetlanego template'u, przez co możliwe jest bardzo wydajne cache'owanie.
\end{itemize}

\subsubsection{Współbieżność}
Wraz z rozwojem możliwości sprzętowych, a dokładniej z rosnącą liczbą rdzeni procesorów, możliwe jest coraz większe wykorzystanie współbieżności w aplikacjach internetowych. Większość frameworków opartych jest na językach obiektowych, co niestety generuje problemy w kwestii współbieżności. Jest tak, ponieważ aby skorzystać z mechanizmu współbieżności, programista musi taką funkcjonalność zaimplementować, oczywiście przy pomocy dostępnych w języku narzędzi. Niestety, współbieżność nie jest prostym zagadnieniem, posiada wiele pułapek, przez co programiści, jeśli nie muszą, zwykle z niej nie korzystają.

Współbieżność, podobnie jak szybkość działania, jest cechą, która osiągnięta została poprzez wybór odpowiedniego języka programowania. \textit{Elixir}, jako język funkcyjny stworzony do tworzenia bardzo wielu procesów, w pełni spełnia wymogi stawiane przez twórców \textit{Phoenix'a}. Nie tylko posiada on bardzo wydajne mechanizmy zapewniające współbieżność, ale przede wszystkim bardzo ułatwia korzystanie z owej współbieżności. I owe ułatwienie pracy programisty jest ważnym czynnikiem popularności \textit{Phoenix'a}. Przykład łatwości korzystania z mechanizmu współbieżności znajduje się na listingu \ref{lst:phoenix_concurrency}, który pochodzi z pozycji literaturowej \cite{phoenix_doctrine}.

\begin{lstlisting}[label={lst:phoenix_concurrency}, caption=Współbieżność w Phoenix'ie]
company_task = Task.async(fn -> find_company(cid) end)
user_task = Task.async(fn -> find_user(uid) end)
cart_task = Task.async(fn -> find_cart(cart_id) end)

company = Task.await(company_task)
user = Task.await(user_task)
cart = Task.await(cart_task)
\end{lstlisting}

Dzięki tak prostym interfejsom, wykonanie kodu z listingu \ref{lst:phoenix_concurrency} zajmie tyle, ile najdłuższe zapytanie do bazy danych, a nie łączny czas zapytań. Dzięki temu dużo lepiej wykorzystywana jest baza danych, co przekłada się na szybkość działania całej aplikacji.

\subsubsection{Wygoda użytkowania}
Wygoda użytkowania jest wypadkową wielu czynników. Z jednej strony jest to wybrany język programowania, który udostępnia programiście w przystępny sposób wiele zaawansowanych mechanizmów, ma ,,przyjazną'' składnię i jest dość prosty w nauce. Z drugiej strony \textit{Phoenix} w swoich założeniach chce się wzorować na innych frameworkach wykorzystując ich najlepsze elementy. Tak więc programista korzysta z rozwiązań, które mogą być mu znane z innych technologii, jak na przykład \textit{Django} lub \textit{Laravel}, co dodatkowo przyspiesza powstawanie aplikacji webowych.

\subsubsection{Niezawodność}
Niezawodność jest podstawą każdej aplikacji, nie tylko internetowej. Nawet najładniejszy, współbieżny i responsywny kod jest bezwartościowy, jeśli nie jest niezawodny. Aplikacje pisane w \textit{Erlang'u} zawsze były bardziej niezawodne od innych, głównie poprzez strukturę linkowania procesów oraz komunikację pomiędzy procesami, co pozwala na efektywną pracę \textit{supervisor'a} \cite{phoenix_doctrine}.

Po raz kolejny jedno z głównych założeń frameworka jest głęboko zakorzenione w przeznaczeniu języka programowania. Wysoka niezawodność jest oczywiście celem praktycznie wszystkich aplikacji, ponieważ błędy aplikacji są bardzo kosztowne dla ich właścicieli.

Dla programistów niezawodność fundamentów, na których budują funkcjonalność aplikacji, jest nieoceniona. Dużo łatwiej tworzy się aplikację mając pewność, że abstrakcje nałożone przez framework są wydajne i niezawodne, przez co można skupić się na tworzeniu funkcjonalności.

\subsection{Elementy składowe}
\textit{Phoenix} jest nadrzędną warstwą w wielowarstwowym systemie zaprojektowanym, aby być modularnym i elastycznym. Pozostałe warstwy zawierają narzędzia takie jak \textit{Plug} (odpowiedzialny za modularność), \textit{Ecto} (odpowiedzialny za interakcję z bazą danych), \textit{Cowboy} (serwer HTTP Erlanga) \cite{phoenix_docs}.

Efektem połączenia wszystkich warstw są następujące elementy:
\begin{itemize}
  \item \textbf{endpoint}, który jako pierwszy zajmuje się zapytaniami, odpowiednio je obsługuje i przekazuje do routera,
  \item \textbf{router} - parsuje przychodzące zapytania i przekierowuje je do odpowiednich kontrolerów i akcji,
  \item \textbf{kontroler} - dostarcza on akcje, które obsługują zapytanie (przetwarzanie danych, przekazanie ich do widoków, generowanie HTML przekazywanych do przeglądarki),
  \item \textbf{szablony} - w połączeniu z danymi oraz po pewnym przetworzeniu generują widoki,
  \item \textbf{widoki}, które są warstwą prezentacji, czyli wizualnym efektem działania aplikacji,
  \item \textbf{kanały} - zarządzają websocketami, które umożliwają komunikację w czasie rzeczywisttym pomiędzy serwerem, a klientem.
\end{itemize}

\subsection{Język programowania - Elixir} % https://elixir-lang.org/
\label{phoenix:elixir}
Podobnie, jak w przypadku \textit{Ruby on Rails}, duży wpływ na jakość użytkowania \textit{Phoenix'a} ma język programowania, w którym jest on stworzony. \textit{Elixir} jest kompilowanym językiem funkcyjnym, który uruchamiany jest na maszynie wirtualnej \textit{Erlanga}. Dodatkowo, jak piszą jego twórcy, jest językiem programowania zaprojektowanym do tworzenia skalowalnych i łatwych w utrzymaniu aplikacji \cite{elixir}.

Wybór tego języka programowania umożliwia zrealizowanie jednych z podstawowych zadań \textit{Phoenix'a} - zapewnienie wysokiej wydajności oraz niezawodności.

Dodatkowo twórcy zwracają uwagę na przyjazną składnię, co stanowczo ma wpływ na popularność frameworka. Jest tak, ponieważ programiści zwykle wolą czerpać przyjemność z używania ,,ładnego'' języka, niż uczyć się i używać mało przyjaznego języka programowania. \textit{Elixir}, jako pierwszy funkcyjny język programowania, wspiera makra z rodziny języków \textit{Lisp}, lecz robi to stosując bardziej naturalną składnię \cite{phoenix_doctrine}.

\subsection{Pozostałe cechy}
\subsubsection{Biblioteki}
Idea centralnego repozytorium paczek jest bardzo popularna wśród większości języków programowania. Ułatwia ono pracę w aplikacją, dodawanie nowych zależności nie jest problematyczne, a błędy dotyczące niezgodności wersji zależności są wyeliminowane. Dla języka \textit{Elixir} domyślnym menadżerem paczek jest \textit{Hex}.

\begin{figure}[h]
  \centering
  \includegraphics[width=.4\linewidth]{images/hex_stats}
  \caption{Statystyki pobrań menedżera pakietów Hex.}
  \label{fig:hex_stats}
\end{figure}

W momencie powstawania niniejszej pracy, dostępnych jest ok 4,5 tysiąca bibliotek w oficjalnym repozytorium  \textit{Hex}. W porównaniu do innych, będących na rynku dłużej języków i frameworków, jest to niewielka liczba. Biorąc natomiast pod uwagę rosnącą popularność \textit{Phoenix'a}, można założyć iż ta liczba będzie rosnąć. Obecnie istniejące paczki są niekiedy odpowiednikami istniejących już paczek napisanych w innych językach. Niestety, bardzo często paczki te, z racji na krótki okres istnienia, są mocno niedopracowane.

\section{Express}
\textit{Express} jest minimalistycznym i bardzo elastycznym frameworkiem webowym. Framework ten powstał poprzez dostarczenie wrapperów dla API udostępnianego przez platformę \textit{Node.js}. \textit{Express}, ze względu na swoją budowę, można traktować jako podstawę do budowy innych frameworków. Framework ten jest dostępny jako wolne oprogramowanie pod licencją MIT i komercyjnie wspierany jest przez firmę \textit{StrongLoop}. \textit{Express} nie jest frameworkiem typu \textit{full-stack}, jest on nastawiony na możliwość dowolnej konfiguracji zależności niezbędnych w projekcie.

\subsection{Podstawowe założenia}
% http://noeticforce.com/best-nodejs-frameworks-for-web-and-app-development
% Sinatra inspired!!!
Pierwotną ideą powstania \textit{Express'a} była chęć stworzenia frameworka podobnego do istniejącego w języku programowania \textit{Ruby} frameworka \textit{Sinatra}. Z tego względu oba te frameworki współdzielą podejście do rozwiązywania problemów oraz struktury kodu.

\subsubsection{Configuration over convention}
Głównym założeniem frameworka \textit{Express} jest dostarczenie programistom pełnej elastyczności i możliwości wyboru poszczególnych składowych aplikacji. W skład frameworku nie wchodzą więc biblioteki odpowiedzialne m.in. za:
\begin{itemize}
  \item komunikację z bazą danych,
  \item autentykację użytkowników,
  \item silnik szablonów.
\end{itemize}

Zastosowanie podejścia \textit{configuration over convention} może być problematyczne w przypadku rozpoczynania swojej przygody z \textit{Express'em}. W sytuacji, kiedy framework nie dostarcza wbudowanych mechanizmów, jak np. wcześniej wymieniony adapter do bazy danych, programista nie znający dostępnych bibliotek może mieć duże problemy z wyborem odpowiedniego mechanizmu.

\subsubsection{Organizacja struktury aplikacji}
Ze względu na podejście \textit{convention over configuration}, \textit{Express} nie narzuca programistom konkretnej struktury aplikacji. W żaden sposób nie jest wyróżnione podejście, które najczęściej można spotkać w aplikacjach webowych, czyli \textit{Model-View-Controller}. Programista może wybrać dowolny wzorzec projektowy, bądź też nie zastosować żadnego, jeśli taka jest jego wola.

\subsection{Podstawa dla innych frameworków}
% typy zbudowanych frameworków + nazwy
\textit{Express} bez żadnych dodatkowych bibliotek, czyli od razu po instalacji, nie dostarcza wielu, niekiedy ważnych, funkcjonalności. Programiści korzystający z tego frameworka potrzebowali jednak tych samych narzędzi w przypadku tworzenia aplikacji tego samego typu. W momencie, kiedy za każdym razem musieli dołączać do projektu i konfigurować te same biblioteki, zaczęły powstawać bardziej ,,kompletne'' frameworki, które bazowały na \textit{Expressie}. W ten sposób powstały następujące frameworki:
\begin{itemize}
  \item LoopBack - stworzony do budowy REST API,
  \item ItemsAPI - framework łączący funkcjonalność \textit{Elastichsearch'a} i \textit{Express'a},
  \item KeystoneJS - \textit{Content Management System},
  \item MEAN - framework typu full-stack,
  \item Feathers - stworzony do budowy REST API,
  \item Sails.js - framework MVC typu full-stack,
  \item Hydra-Express - framework stworzony do architektury mikroserwisów.
\end{itemize}

\subsection{Biblioteki}
Większość języków programowania posiada swój menedżer paczek, nie inaczej jest w przypadku języka \textit{JavaScript}. W tym środowisku największą popularność zyskał \textit{npm}. Jako, że \textit{npm} jest menedżerem paczek języka, a nie frameworka, można tam oczywiście znaleźć paczki niekompatybilne z \textit{Expressem}, lecz jest to cecha wszystkich menedżerów stworzonych dla konkretnego języka programowania.

Na oficjalnej stronie \textit{npm} \cite{npm_site} przeczytać można, że dostępnych jest ponad 470 tysięcy paczek. Z repozytorium \textit{npm} tygodniowo pobieranych jest 2 365 813 490 paczek.

\chapter{Analiza porównawcza}
\section{Opisowe porównanie charakterystyk wybranych frameworków}
Naturalnym jest, że frameworki webowe różnią się od siebie pod wieloma względami. Różnice można zauważać od samego początku, czyli idei powstania, poprzez podejście do programisty, na sposobie działania i wydajności kończac. Zwykle przyczyną różnorodności jest sama filozofia frameworka, dążenie do doskonałości. Nie jest możliwe osiągnięcie optymalnych wartości w każdej z dziedzin, które frameworki obejmują, przez co twórcy muszą iść na większe bądź mniejsze kompromisy. Niekiedy owe różnice nie pojawiają się z przymusu, ale z przyjęcia konkretnych założeń.

Są jednak sytuacje, kiedy frameworki są do siebie bardzo podobne. Zwykle są to sytuacje, kiedy framework z jednego języka programowania przenoszony jest do innego języka. Tak było w przypadku opisywanego \textit{Express'a}, który powstał jako odzwierciedlenie frameworka \textit{Sinatra}. Innym przypadkiem występowania podobieństw jest chęć wykorzystania jakiegoś fragmentu frameworka, który uznawany jest za standard i bez którego programista musi posiadać większą wiedzę aby odpowiednio wykorzystywać framework.\\

W kolejnych podrozdziałach zostaną przedstawione porównania wybranych frameworków na zasadzie \textit{,,każdy z każdym''}. Poza podobieństwami i różnicami w budowie oraz idei działania, zamieszczona została subiektywna opinia autora na temat sytuacji, w których jeden framework ma przewagę nad drugim.

\section{Ruby on Rails vs Phoenix}
Jako pierwsze analizie porównawczej zostaną poddane najstarszy i najmłodszy framework spośród opisywanych, czyli \textit{Ruby on Rails} oraz \textit{Phoenix}. Owa różnica ,,wieku'' mocno rzutuje na całokształ tych frameworków.  Pierwszy ma już stabilną, wręcz nienaruszalną, pozyję na rynku, bardzo dużą społeczność oraz niezliczoną ilość materiałów dostępnych w Internecie.
Drugi natomiast, co oczywiście jest efektem wielu składowych, ma spory potencjał. Oczywiście nie jest to pierwszy, ani jedyny, framework, który owy potencjał posiada. Jednakże w przypadku \textit{Phoenix'a} jest duża szansa, iż będzie on wykorzystany. Przyczynić się do tego może środowisko programistów \textit{Ruby on Rails}, ponieważ już teraz duża ilość programistów albo mocno się \textit{Phoenixem} interesuje, albo zdecydowało się zmienić technologię na \textit{Elixir'a} i \textit{Phoenix'a}.

% !!filozofia działania
% idea powstania
% !!architektura, elementy składowe
% !!wygoda użytkowania
% szybkość powstawania aplikacji
% !!dostępność najczęściej wykorzystywanych bibliotek (system użytkowników, zapisywanie plików w chmurze, przetwarzanie w tle)
% testowanie aplikacji

\subsection{Filozofia działania}
\textit{Ruby on Rails} oraz \textit{Phoenix} posiadają elementy wspólne jeśli chodzi o sposób działania. Jest to spowodowane faktem, iż z założenia \textit{Phoenix} miał wykorzystywać najlepsze elementy z innych frameworków.

Jeśli chodzi o filozofię działania, oba frameworki są zgodne w kwestii chęci ułatwienia pracy programistom. 
\subsection{Architektura aplikacji, elementy składowe}
\subsection{Wygoda użytkowania}
\subsection{Dostępność najczęściej wykorzystywanych bibliotek}
\subsection{Subiektywna opinia}

\section{Ruby on Rails vs Express}
\subsection{Filozofia działania}
\subsection{Architektura aplikacji, elementy składowe}
\subsection{Wygoda użytkowania}
\subsection{Dostępność najczęściej wykorzystywanych bibliotek}
\subsection{Subiektywna opinia}

\section{Phoenix vs Express}
\subsection{Filozofia działania}
\subsection{Architektura aplikacji, elementy składowe}
\subsection{Wygoda użytkowania}
\subsection{Dostępność najczęściej wykorzystywanych bibliotek}
\subsection{Subiektywna opinia}

\section{Subiektywna ocena}

\chapter{Implementacja}
\section{Ruby on Rails}
\section{Phoenix}
\section{Express}

\chapter{Projekt komputerowego środowiska eksperymentalnego}
\section{Plan prowadzenia eksperymentów}

\section{Wykorzystane narzędzia}
\subsection{Docker}
\section{Benchmarki}
% https://www.sitepoint.com/tools-testing-website-performance/
\subsection{Ruby}
% http://rubylearning.com/blog/2013/06/19/how-do-i-benchmark-ruby-code/
\subsection{Elixir}
% https://github.com/PragTob/benchee
\subsection{JavaScript}
% https://benchmarkjs.com/

\chapter{Analiza wydajnościowa}
\label{cha:analiza_wydajnosciowa}
\section{Metody mierzenia wydajności aplikacji internetowych}
\section{Wyniki badań}

\chapter{Podsumowanie}
\renewcommand\bibname{Literatura}
\begin{thebibliography}{inteligencja}
	\addcontentsline{toc}{chapter}{Literatura}

  \bibitem{historia}
  \emph{Historia Internetu}, dostęp pod adresem: \url{https://pl.wikipedia.org/wiki/Historia_Internetu}, aktualne na dzień 1.04.2017r.

  \bibitem{framework}
  \emph{Software framework}, dostęp pod adresem: \url{https://en.wikipedia.org/wiki/Software_framework}, aktualne na dzień 1.04.2017r.

	\bibitem{rails_guide}
	\emph{Ruby on Rails Guides}, dostęp pod adresem: \url{http://guides.rubyonrails.org/},\\ aktualne na dzień 14.06.2017r.

  \bibitem{rails_doctrine}
  \emph{Ruby on Rails Doctrine}, dostęp pod adresem: \url{http://rubyonrails.org/doctrine/}, aktualne na dzień 1.05.2017r.

  \bibitem{phoenix_doctrine}
  McCord R., Tate B., Valim J., \emph{Programming Phoenix}, The Pragmatic Programmers LLC, 2016

  \bibitem{phoenix_docs}
  \emph{Phoenix Guides}, dostęp pod adresem: \url{http://www.phoenixframework.org/docs/resources}, aktualne na dzień 6.05.2017r.

	\bibitem{cleancode}
	Martin, R. \emph{Czysty kod. Podręcznik dobrego programisty}, Gliwice, Wydawnictwo Helion 2010

  \bibitem{benchmarking_tools}
  Diwan, A. \emph{Tools for Testing Website Performance}, dostęp pod adresem: \url{https://www.sitepoint.com/tools-testing-website-performance/}, \\ aktualne na dzień 18.03.2017r.

  \bibitem{dry}
  \emph{Don't Repeat Yourself}, dostęp pod adresem: \url{http://deviq.com/don-t-repeat-yourself/}, aktualne na dzień 3.05.2017r.

  \bibitem{docker_what_container}
  \emph{What is a Container}, dostęp pod adresem: \url{https://www.docker.com/what-container}, aktualne na dzień 27.05.2017r.

  \bibitem{docker_prez}
  \emph{Docker. Kontener aplikacyjny nie tylko dla programistów}, dostęp pod adresem: \url{https://dsg.cs.put.poznan.pl/wiki/_media/workshop/docker-skisr.pdf}, aktualne na dzień 27.05.2017r.

  \bibitem{wiki_crud}
  \emph{CRUD}, dostęp pod adresem: \url{https://pl.wikipedia.org/wiki/CRUD}, aktualne na dzień 27.05.2017r.

  \bibitem{elixir}
  \emph{Elixir Language}, dostęp pod adresem: \url{https://elixir-lang.org/}, aktualne na dzień 16.05.2017r.

  \bibitem{elixir_medium}
  Mazaika, K. \emph{Why I'm betting on Elixir}, dostęp pod adresem: \url{https://medium.com/@kenmazaika/why-im-betting-on-elixir-7c8f847b58}, aktualne na dzień 28.05.2017r.

  \bibitem{express}
  \emph{Express Guides}, dostęp pod adresem: \url{https://expressjs.com/}, aktualne na dzień 10.06.2017r.

  \bibitem{express_pro}
  % http://www.apress.com/gp/book/9781484200384
  Mardanm A. \emph{Pro Express.js}, Apress, 2014

  \bibitem{npm_site}
  \emph{npm Homepage}, dostęp pod adresem: \url{https://www.npmjs.com/}, aktualne na dzień 10.06.2017r.

\end{thebibliography}
\end{document}
